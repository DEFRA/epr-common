using NUnit.Framework;

namespace EPR.Common.Sample.Tests.Data
{
    using System;
    using System.Collections.Generic;
    using System.ComponentModel.DataAnnotations.Schema;
    using System.IO;
    using System.Linq;
    using System.Reflection;
    using System.Text;
    using EPR.Common.Functions.Database.Entities;
    using EPR.Common.Functions.Database.Entities.Interfaces;
    using EPR.Common.Sample.Data;
    using FluentAssertions;
    using Functions.Extensions;
    using Microsoft.EntityFrameworkCore;

    [Parallelizable(ParallelScope.Fixtures)]
    [TestFixture]
    public class EntityTypeStaticAnalysis
    {
        private static readonly ISet<Type> IgnoredAttributeTypes = new HashSet<Type>
        {
            typeof(DatabaseGeneratedAttribute),
        };

        private static readonly IDictionary<Type, Type> BaseTypeToBaseAuditType = new Dictionary<Type, Type>
        {
            { typeof(EntityBase), typeof(AuditEntityBase) },
        };

        [Test]
        public void AutoFix_AuditTypes()
        {
            var tablesFolder = SolutionFolder().Directory("EPR.Common.Sample.Data").Directory("Tables");

            var errorMessage = new StringBuilder();
            var entityTypes = typeof(EprContext).GetProperties()
                .Where(propertyInfo => propertyInfo.PropertyType.IsGenericType && propertyInfo.PropertyType.GetGenericTypeDefinition() == typeof(DbSet<>))
                .Select(propertyInfo => propertyInfo.PropertyType.GetGenericArguments()[0])
                .Where(entityType => !typeof(IAudit).IsAssignableFrom(entityType))
                .ToList();
            foreach (var entityType in entityTypes)
            {
                if (EprContext.UncheckedEntities.Contains(entityType))
                {
                    continue;
                }

                var entityFile = tablesFolder.File($"{entityType.Name}.cs");
                var auditFile = tablesFolder.Directory("Audit").File($"{entityType.Name}Audit.cs");

                foreach (var file in new[] { entityFile, auditFile })
                {
                    if (!file.Exists)
                    {
                        file.WriteAllText(string.Empty, Encoding.UTF8);
                        errorMessage.AppendLine($"{file} should exist");
                    }
                }

                var expectedAuditFileBuilder = new StringBuilder();
                expectedAuditFileBuilder.AppendLine($@"// <auto-generated />
namespace EPR.Common.Data.Tables.Audit
{{
    using System;
    using EPR.Common.Sample.Data.Tables;
    using EPR.Common.Functions.Database.Entities.Interfaces;");

                foreach (var line in entityFile.ReadAllLines().Where(line => line.Trim().StartsWith("using ") && !line.Trim().EndsWith(" System;") && !line.Trim().EndsWith(" EPR.Common.Functions.Database.Entities.Interfaces;")))
                {
                    expectedAuditFileBuilder.AppendLine(line);
                }

                if (!BaseTypeToBaseAuditType.TryGetValue(entityType.BaseType, out Type baseClass))
                {
                    errorMessage.AppendLine($"{entityFile} should derive from a base class defined in BaseTypeToBaseAuditType");
                }

                expectedAuditFileBuilder.AppendLine($@"
    public class {entityType.Name}Audit : {baseClass.Name}, IAudit<{entityType.Name}>
    {{");

                var entityProperties = entityType.GetProperties(BindingFlags.Instance | BindingFlags.Public | BindingFlags.DeclaredOnly);
                if (entityProperties.Length > 0)
                {
                    foreach (var entityProperty in entityProperties)
                    {
                            if (entityTypes.Contains(entityProperty.PropertyType) ||
                                entityProperty.CustomAttributes.Any(
                                    attr => attr.AttributeType == typeof(NotMappedAttribute)))
                        {
                            continue;
                        }

                        ProcessAttributes(entityProperty, expectedAuditFileBuilder);

                        if (entityProperty.PropertyType.IsGenericType &&
                            entityProperty.PropertyType.GetGenericTypeDefinition() == typeof(ICollection<>)) 
                        {
                            Type itemType = entityProperty.PropertyType.GetGenericArguments()[0];
                            expectedAuditFileBuilder.AppendLine(
                                $@"        public ICollection<{TypeName(itemType)}> _{entityProperty.Name} {{ get; set; }}{Environment.NewLine}");
                        }
                        else
                        {
                            expectedAuditFileBuilder.AppendLine(
                                $@"        public {TypeName(entityProperty.PropertyType)} _{entityProperty.Name} {{ get; set; }}{Environment.NewLine}");
                        }
                    }

                    expectedAuditFileBuilder.Remove(expectedAuditFileBuilder.Length - 1 - Environment.NewLine.Length, Environment.NewLine.Length);
                }

                expectedAuditFileBuilder.AppendLine($@"    }}
}}");

                var expectedAuditFile = expectedAuditFileBuilder.ToString();
                if (auditFile.ReadAllText() != expectedAuditFile)
                {
                    auditFile.WriteAllText(expectedAuditFile, Encoding.UTF8);
                    errorMessage.AppendLine($"{auditFile} should follow a standard pattern");
                }

                foreach (var line in entityFile.ReadAllLines())
                {
                    if (line.Contains("class") && !line.Contains("public") && !line.Contains("EntityBase"))
                    {
                        errorMessage.AppendLine($"{entityFile} should be public and derive from EntityBase");
                    }
                }
            }

            // This will output the error messsage if the tests fails;
            errorMessage.ToString().Should().Be(string.Empty);

            errorMessage.Length.Should().Be(0, errorMessage.ToString());
        }

        private static void ProcessAttributes(PropertyInfo entityProperty, StringBuilder expectedAuditFileBuilder)
        {
            foreach (var attributeData in entityProperty.CustomAttributes)
            {
                if (IgnoredAttributeTypes.Contains(attributeData.AttributeType) || attributeData.AttributeType.Name == "NullableAttribute")
                {
                    continue;
                }

                var positionalArguments = attributeData.ConstructorArguments.Select(arg => arg.Value?.ToString());
                var keywordArguments = (attributeData.NamedArguments ?? Enumerable.Empty<CustomAttributeNamedArgument>()).Select(arg => arg.ToString());
                expectedAuditFileBuilder.AppendLine($"        [{TypeName(attributeData.AttributeType)}({string.Join(", ", positionalArguments.Concat(keywordArguments))})]");
            }
        }

        private static string TypeName(Type type) =>
            (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(Nullable<>)) ? $"{type.GetGenericArguments()[0].Name}?" : type.Name;

        private static DirectoryInfo SolutionFolder()
        {
            var folder = new DirectoryInfo(TestContext.CurrentContext.TestDirectory);
            while (!folder.EnumerateFiles("*.sln").Any())
            {
                folder = folder.Parent;
            }

            return folder;
        }
    }
}